# 数据结构与算法笔记

[toc]

## 一、稀疏数组-压缩

从五子棋游戏引入，如何记录棋盘和先后手？

二维数组？--> 会记录众多默认的0值，存储空间浪费

稀疏数组，第0条记录记录矩阵的大小、记录条数；后续的记录点的信息，横纵坐标和值

**存**：n+1行3列（X，Y，值），第一行记录数组的大小和点的数量，后续记录每个点的坐标和值。

**取**：通过第0行知道共多少个点，依据第0行创建数组，通过后续行加点。



## 二、队列-有序列表，先入先出

### 1. 数组模拟队列实现

- **变量**：最大容量，头指针（首个元素的前一个）、尾指针（最后一个元素），存储数组本体

- **方法**：判空、判满、存、取、显示

单向队列使用一次就不能使用、没有达到复用的效果 --> 改造为环形队列

### 2. 数组模拟环形队列

- 变量：最大容量、头指针（直接指向第一个元素）、尾指针（直接指向最后一个元素）、存储数组本体
- **方法**：判空、判满、存、取、显示、计算队列元素个数
  - 判空：头 == 尾
  - 判满：（rear + 1）% maxSize == front
  - 存：rear =（rear + 1）% maxSize
  - 取：front = (front + 1) % maxSize
  - 计算个数：(rear + maxSize - front) % maxSize
  - 显示：从front遍历，至front + 个数，i % maxSize



## 三、链表-有序列表

### 1.单向链表

(data + next)，节点的方式存储，在内存中的存储不连续，分带头节点的和没有头节点的

head(不存放具体数据，表示单链表头) -->  [,] --> [,] --> [,] --> [,null]

需要temp临时指针，遍历temp = temp.next

Demo  -->  LinkedList - [Element(num、next、name、toString)]

- **增**：向尾部加，按序号加
  - temp = head
  - temp.next == null
  - temp.next = new
- **增**：按序号添加
  - temp = head
  - 遍历，temp.next.num > new.num，temp.next = null时退出
  - new.next = temp.next, temp.next = new
  - 特殊：temp.next.num = new.num , 报已有
- **删**：按序号删除
  - temp = head
  - 特殊：temp.next == null，报空
  - 遍历，temp.next.num == num
  - temp.next = temp.next.next
- **改**：按序号修改内容
  - temp = head.next
  - 特殊：temp == null，报空
  - 遍历，temp.num == item.num
  - temp.name = item.name, temp.grades = item.grades
- **查**：查看全部节点
  - temp = head.next
  - 特殊，temp == null，报空
  - 遍历，重写toString
- **查**：计算数组数量
- **查看倒数第k个节点**
  - 判空、计数、k值是否合理？
  - 遍历sum-k次
- **反转链表**
  - 新建一个链表头
  - 通过temp = head.next遍历链表
    - 先用nextNode存储temp.next，因为要编辑这个值
    - temp.next = reverseHead.next
    - reverseHead.next = temp
    - temp = nextNode
  - 通过head.next = reverseHead.next修改原链表

- **逆序打印链表**
  - **分析**：不采用上一个问题反转链表再打印，这样做改变了原来链表的结构还占用了内存，采用可以压入栈中的方式，通过**栈**的<u>先进后出</u>的特点实现逆序打印
  - 遍历链表，将每个节点入栈
  - 出栈，打印
- **按序号合并两顺序链表**
  - 新建一个链表头，新建三个指针分别指向新链表头（**cur**）、待合并链表1元素（**temp**），待合并链表2元素（**anotherTemp**）
  - 判断temp和anotherTemp的num大小决定**cur**应该指向谁
  - cur = cur.next，temp = temp.next / anotherTemp = anotherTemp.next（谁被使用谁更新）
  - 只要遍历完一个链表，就将cur.next指向另一个链表的当前元素，退出



### 2.双向链表

- **单向链表缺点**：①单向链表只能向一个方向查找，双向链表可以向前向后查找 ②单向链表不能独立删除节点，需要依靠辅助节点（temp指向待删除节点的前一个节点）

双向链表除了next还要有一个pre，

​	**增（尾）**：temp向后遍历（next）至null，temp.next = node，node.pre = temp

​	**增**：通过index添加，判断输入的合理性（index>0），两种思路

​		①遍历链表，找到index相等的节点，提示and return；找到temp.next.index > newNode.index，建立从右至左，两个双链接；退出循环时说明未找到，需要添加在尾部

​		②遍历链表（temp.next != null && temp.next.index < newNode.index），退出时temp指向链表尾部或指向需要添加newNode的位置（可能temp.next.index == newNode.index），三种情况需要分别判断

​	**删**：temp至被删除的节点，temp.pre.next = temp.next，temp.next.pre = temp.pre

​	**改**：同单向链表，遍历找到需要修改的节点，修改

​	**查**：temp向后(temp = temp.next)向前(temp = temp.pre)双向遍历



### 3. 循环链表-约瑟夫问题

![image-20240330194753102](.\image\image-20240330194753102.png)

使用**单向循环链表**解决 Boy -> CircleLinkedList -> Josephu，单向环形链表需要一个first

- **创建**环形单向链表
  - 输入 - 需要n个节点，判断合理性，n是否<=1
  - 循环（n次）
    - 若n==1,创建一个first节点 -> new Boy(i)，curBoy -> first
    - 若n!=1, curBoy.next -> new Boy(i), curBoy = curBoy.next
    - curBoy -> first

- **遍历**环形单向链表
  - 判空（first == null）
  - 打印first
  - 创建辅助指针curBoy = first.next，循环（curBoy != first）打印curBoy

- **约瑟夫问题**求解
  - 输入 - n：从第n号开始遍历；k：数到k的人出列
  - 创建辅助指针helper = first，做循环（helper.next != first），指向first的前一个元素
  - 移动到初始位置n：循环（n-1次）移动helper和first
  - 循环（first == helper）,链表中无元素
    - 循环（k - 1次）移动helper和first，此时first指向需要出列的人，helper指向其前一个人
    - 打印first，出圈：first = first.next, helper.next = first; 
  - 打印，剩的一个人



## 四、栈-先入后出

栈顶变化，栈底不变

栈的应用场景：子程序调用、处理递归调用、表达式的转换与求值、二叉树的遍历、图形深度优先搜索

### 1.栈的数组实现

ArrayStack: 栈顶top、最大容量maxSize、承载的数组stack[]

- **构造**：输入 - 最大容量，数组初始化，栈顶指向-1

- **判空**：top = -1

- **判满**：top = maxSize - 1

- **增（入栈）**：输入 - 数据n，判满，top++, stack[top] = n，

- **删（出栈）**：判空，output = stack[top], top--

- **查（从栈顶遍历）**：判空，循环（top != -1），打印stack[top]

### 2.栈的单向链表实现

**ListElement**(序号index, 值value, 指针next)，set、getValue

**LinkedListStack**(栈大小maxSize, 链表头指针head, 栈顶指针temp)

- **构造**：创建一个大小为maxSize的单向链表（head为头指针），栈顶指针temp指向head

- **判空**：temp == head

- **判满**：temp.next == null

- **增（入栈）**：输入 - 数据n，判满，temp = temp.next, temp.setValue(n)，

- **删（出栈）**：判空，存下temp.getValue, 创建新指针newTemp循环至temp前一个，temp = newTemp, 返回存下的值

- **查（从栈顶遍历）**：判空，创建helper指针，循环（i从temp.index逆序遍历至0）[循环至helper指向index为i的节点，打印节点，恢复helper指向头节点]

### 3.栈实现综合计算器

使用栈完成计算一个表达式的结果：numStack + operStack

- 通过index遍历表达式输入值（字符串）

  - index指向的是一个数字，直接入数栈numStack

  - index指向的是一个符号
    - 当前符号栈空，直接入栈
    - 若符号栈非空，判断符号的优先级
      - 优先级比栈中的操作符低或相同：需要从数字栈中pop出两个数、符号栈中pop出一个符号进行运算，得到结果入栈，将当前运算符入栈
      - 优先级比栈中操作高，直接入栈

- 顺序从数栈和符号栈中pop出相应内容进行计算

- 最后数栈仅剩一个数字

**使用 3+2*6-2 推演一遍**：

1. 3入栈
2. +入栈
3. 2入栈
4. *判断优先级更高，入栈
5. 6入栈
6. — 判断优先级更低，进行计算
   1. 从数栈pop出6和2，从符号栈pop出*
   2. 将计算结果6*2存入数栈
   3. 将 — 存入符号栈

7. 2入栈，遍历结束开始计算
8. 从数栈pop出2和12，从符号栈pop出 —，结果为10，存入数栈
9. 从数栈pop出10和3，从符号栈pop出+，结果为13，存入数栈
10. 因为符号栈为空，此时数栈仅剩一个数，计算结束返回结果

**代码**：isOper判别是否符号、isNum判别是否数字、priority优先级、cal计算两数结果

### 4.前缀中缀后缀表达式

**前缀表达式**：从右向左遍历，运算符位于操作数之前，遇到数字入栈，遇到符号取数运算

**中缀表达式**：正常的思维形式的表达式

**后缀表达式**：也叫逆波兰表达式，从左至右遍历，遇数字入栈，遇到符号取数运算

举例：(3+4)×5-6的前缀表达式为-×+3456，先弹出 - / 后弹出；后缀表达式为34+5×6-，后弹出 -/先弹出

### 5.栈实现逆波兰计算器

输入一个后缀表达式，用栈实现计算，支持小括号和多位数整数，仅支持整数

代码：isOper判符号、isNum判数字、cal计算两数结果

### 6.中缀表达式转后缀表达式

人容易理解的表达式 -> 计算机容易理解的表达式

例如：1+((2+3)*4)-5 => 1 2 3 + 4 * + 5 -

**思路分析**：

- 初始化两个栈（s1, s2）
- 从左至右扫描中缀表达式
  - 若为数字 -> s2
  - 若为运算符
    - 如果s1为空或者s1栈顶为 “(”  ，将此运算符直接入栈s1
    - 否则，如果该运算符优先级高于s1栈顶的运算符，将此运算符直接入栈s1
    - 否则，将s1栈顶的运算符弹出并压入s2中，再次判断该运算符与s1新栈顶的优先级
  - 若为括号
    - 如果是“(”，直接压入s1
    - 如果是“)”，依次弹出s1栈顶的运算符压入s2，直到遇到左括号为止，消除这对括号
- 扫描完成后将s1中剩余的符号压入s2
- s2出栈后的逆序为后缀表达式

## 五、递归

递归就是自己调用自己，每次调用时不相同，打印问题和阶乘问题

![image-20240416191400236](.\image\image-20240416191400236.png)

![image-20240416191219376](.\image\image-20240416191219376.png)

递归适合解决的问题：8皇后，汉诺塔，阶乘，迷宫，球和篮子

算法中使用：快排，归并排序，二分查找，分治算法

使用栈解决的问题 -> 使用递归代码更简洁

### 1.递归的重要原则

- 执行一个方法时就创建一个新的受保护的独立空间（栈空间）

- 方法的局部变量是独立的，不会相互影响

- 方法中使用引用类型变量，共享该引用型数据

- 递归必须向退出递归条件逼近，否则就是无限递归，出现StackOverFlowError

- 当一个方法执行完毕，或者遇到return就会返回，谁调用就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕

### 2.迷宫问题

![image-20240416192759858](.\image\image-20240416192759858.png)

![image-20240416203152077](.\image\image-20240416203152077.png)

### 3.八皇后问题

8*8，不能同一行、同一列、同一斜线，92种

![image-20240417184222940](.\image\image-20240417184222940.png)

![image-20240417192718375](.\image\image-20240417192718375.png)



## 六、排序算法

排序又分内部排序和外部排序（数据量过大无法全部加载到内存中，借助外部存储，如文件等）

**常见的排序算法**分类：

![image-20240417193256586](.\image\image-20240417193256586.png)

度量程序执行时间：事后统计方法、事前估算方法

### 1.算法的时间复杂度

- 时间频度：算法中语句的执行次数成为语句频度或事件频度 --> T(n)
  - 忽略常数项（随着n 👆 ，2n和2n+20二者不断接近）
  - 忽略低次项（随着n 👆 ，2n^2+3n+10和2n^2二者不断接近）
  - 忽略系数（随着n 👆 ，2n^2+3n和5n^2+3n二者不断接近）
- 时间复杂度
  - 辅助函数f(n)为时间频度T(n)的同量级函数，记作T(n) = O(f(n))，称O(f(n))为算法的渐进时间复杂度，简称**时间复杂度**
  - 常见的时间复杂度（复杂度由低到高1->8）
    - ![image-20240417195753273](.\image\image-20240417195753273.png)

![image-20240417200158036](.\image\image-20240417200158036.png)

![image-20240417200450001](.\image\image-20240417200450001.png)

![image-20240417200540849](.\image\image-20240417200540849.png)

![image-20240417200617754](.\image\image-20240417200617754.png)

![image-20240417200642662](.\image\image-20240417200642662.png)



- **平均时间复杂度和最坏时间复杂度**
  - **平均时间复杂度**：所有可能的输入实例均以等概率出现的情况下，该算法的运行时间
  - **最坏时间复杂度**：在任何输入实例上运行时间的界限，算法运行时间不会比最坏情况更长（√，常用）
  - 平均时间复杂度和最坏时间复杂度是否一致和算法有关

![image-20240418183554860](.\image\image-20240418183554860.png)



### 2.算法的空间复杂度

空间复杂度 --> 该算法运行时所耗费的存储空间，是问题规模n的函数

空间复杂度是对算法在运行过程中临时占用存储空间大小的度量，算法分析更看重**时间复杂度**

很多算法是空间换时间



 ### 3.冒泡排序 O(n^2)

两个索引滑动，比较次数减少，通过对序列从前向后，依次比较相邻元素的值，若逆序则交换

**优化**：如果某次排序的过程中没有发生交换，说明序列已经有序，退出程序

**规则**：①共要进行n-1次排序 ②每次排序次数逐渐减少 ③如果没有交换，提前结束

![image-20240418185942330](.\image\image-20240418185942330.png)

![image-20240418194515903](.\image\image-20240418194515903.png)



### 4.选择排序 O(n^2)

第一次从0 - n-1选到最小值元素，与0位置元素交换

第二次从1 - n-1选到最小值元素，与1位置元素交换

第三次从2 - n-1选到最小值元素，与2位置元素交换

...

第n-1次从n-2 - n-1选到最小值元素，与n-2位置元素交换

共n-1轮排序

![image-20240421100647975](.\image\image-20240421100647975.png)



### 5.插入排序 O(n^2)

把n个元素看为一个有序表和一个无序表，有序表初始仅有一个元素，无序表右n-1个元素，排序过程中每次从无序表中取出第一个元素，插入有序表使顺序合理

![image-20240421110939230](.\image\image-20240421110939230.png)

{【有序列表】<---【无序列表】}

![image-20240421110205822](.\image\image-20240421110205822.png)



### 6. 希尔排序

简单插入排序如果在尾部处理较小的值会进行较多次交换，效率较低。希尔排序是更高效的插入排序，是改进

- 思想：将数据按下标的一定增量分组，每组分别插入排序，增量逐渐减少，直至为1，恰好完成排序

gap = length / 2，gap = gap / 2，直至为gap = 1

![image-20240620093736368](.\image\image-20240620093736368.png)



### 7. 快速排序

快速排序是对冒泡排序的一种改进。

- **基本思想**：将一个序列分割成两个部分，其中一部分的所有数据都比另一部分的所有数据要小，在按此方法对两组数据分别进行快速排序，递归完成

![image-20240622101345105](.\image\image-20240622101345105.png)

注意点：

- 以谁为中心都没问题，递归会解决偏离的问题
- 找到待交换的left和right之后要**判断是否right<=left**，这时已满足条件，要break不交换
- 完成一次分类之后，要先判断是否**left == right**，各自后移和前移，防止无限递归内存溢出
- 递归的条件时left < r，right > l；不满足递归条件说明此时已经只剩一个元素

![image-20240622142353955](.\image\image-20240622142353955.png)



### 8. 归并排序

使用归并的思想，将问题分成一些小的问题然后递归求解，最后将分的小问题的答案合并为已一体

![image-20240622143012765](.\image\image-20240622143012765.png)

“治”阶段的处理：

![image-20240622143356431](.\image\image-20240622143356431.png)



注意点：

- 把无序的数组一步步从2个元素到整个数组开始变得有序起来，重点是merge方法
- merge时从两个序列中按序取出较小的，先遍历完一个，然后将另一个填入，最后复制回原数组完成一次归并排序

- 注意复制回原数组时的index，起始是从left开始的

![image-20240622153957652](.\image\image-20240622153957652.png)

![image-20240622154048882](.\image\image-20240622154048882.png)



### 9. 基数排序（桶排序）

- 属于“分配式排序”，通过键值的各个位的值将要排序的元素分配至某些桶中达到排序的作用（经典的空间换时间的算法）

- 基数排序是稳定性的排序，技术排序是效率高的稳定性排序法

- 基数排序是桶排序的扩展，速度快
- 占用内存很大，海量数据容易造成OutOfMemeryError；有负数的数组不适用

思路：将整数按位数切割成不同的数字，然后按每个位数分别比较

基本思想：

- 将所有待比较的数值统一为同样的数位长度，短的补零，然后从最低位开始依次进行一次排序，这样最位一直到最高位变成一个有序序列

![image-20240622160023087](.\image\image-20240622160023087.png)

![image-20240622160215240](.\image\image-20240622160215240.png)

![image-20240622160352006](.\image\image-20240622160352006.png)

做几轮取决于最大数字的位数

![image-20240622165600813](.\image\image-20240622165600813.png)



### 10. 排序算法比较

![image-20240622171829100](.\image\image-20240622171829100.png)





## 七、哈希表

![image-20240620094133688](.\image\image-20240620094133688.png)

![image-20240620094335102](.\image\image-20240620094335102.png)

- 问题：使用哈希表来管理雇员信息

![image-20240620094736577](.\image\image-20240620094736577.png)



Demo -- hashTable -- EmpLinkedList -- Emp



## 八、树结构

### 1. 数组，链表和树存储方式对比

- **数组**：通过下标访问元素，速度快。有序数组可以使用二分查找。缺点是，如果检索某个具体的值或者插入某个值会整体移动，效率低
- **链表**：存储方式上有优化，如插入一个数值节点只需要将插入节点链接到链表中，删除效率也很好。缺点是，检索时效率较低，需要从头遍历
- **树**：能提高数据存储、读取的效率，比如利用二叉树排序树，既可以保证数据的检索速度，也能够保证数据的插入，删除，修改的速度

![image-20240620111606618](.\image\image-20240620111606618.png)

### 2. 树的常用术语

![image-20240620112123367](.\image\image-20240620112123367.png)

- **二叉树**：每个节点最多只能有两个子节点的树，左节点和右节点
- **满二叉树**：二叉树的所有叶子节点都在最后一层，并且节点总数=2^N-1，N为层数，则为满二叉树。
- **完全二叉树**：如果二叉树搜索的叶子节点都在最后一层和倒数第二层，且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，称为完全二叉树

![image-20240620112739042](.\image\image-20240620112739042.png)

### 3. 二叉树遍历

- **前序遍历**：**父节点** -- 左子树 -- 右子树
  - 先输出当前节点（root） 
  - 如果左子节点不为空，递归继续前序遍历 
  - 如果右子节点不为空，则递归继续前序遍历

- **中序遍历**：左子树 -- **父节点** -- 右子树
  - 如果左子节点不为空，递归继续中序遍历 
  - 输出当前节点
  - 如果右子节点不为空，则递归继续中序遍历

- **后序遍历**：左子树 -- 右子树 -- **父节点**
  - 如果左子节点不为空，递归继续后序遍历 
  - 如果右子节点不为空，则递归继续后序遍历
  - 输出当前节点

![image-20240620163226584](.\image\image-20240620163226584.png)

![image-20240620163253514](.\image\image-20240620163253514.png)

![image-20240620163312341](.\image\image-20240620163312341.png)



### 4. 二叉树查找

![image-20240620163559973](.\image\image-20240620163559973.png)

![image-20240620165433976](.\image\image-20240620165433976.png)

还是递归



### 5. 删除节点

![image-20240620171914137](.\image\image-20240620171914137.png)

![image-20240620174710198](.\image\image-20240620174710198.png)



### 6. 顺序存储二叉树

数组存储方式和树的存储方式可以互相转换，数组可以转换成树，树也可以转换成数组

![image-20240620182151872](.\image\image-20240620182151872.png)

![image-20240620182548469](.\image\image-20240620182548469.png)

 自顶向下每层从左到右按顺序来。遍历数组仍然按照树的遍历顺序来（前序，中序，后序）

![image-20240620210000739](.\image\image-20240620210000739.png)



### 7. 线索化二叉树

将数列{1， 3， 6，8， 10， 14}构建成二叉树

- n个节点的二叉链表中含有 n+1 个空指针，利用这些空指针存放节点在某种遍历次序下的**前驱**和**后继**节点的指针（这种附加的指针称为线索）

- 加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树，根据线索性质不同又可分为前序线索二叉树、中序线索二叉树和后序线索二叉树。

![image-20240620212640858](.\image\image-20240620212640858.png)

![image-20240620212816928](.\image\image-20240620212816928.png)
