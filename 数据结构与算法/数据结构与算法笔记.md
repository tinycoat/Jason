# 数据结构与算法笔记

[toc]

## 一、稀疏数组-压缩

从五子棋游戏引入，如何记录棋盘和先后手？

二维数组？--> 会记录众多默认的0值，存储空间浪费

稀疏数组，第0条记录记录矩阵的大小、记录条数；后续的记录点的信息，横纵坐标和值

**存**：n+1行3列（X，Y，值），第一行记录数组的大小和点的数量，后续记录每个点的坐标和值。

**取**：通过第0行知道共多少个点，依据第0行创建数组，通过后续行加点。



## 二、队列-有序列表，先入先出

### 1. 数组模拟队列实现

- **变量**：最大容量，头指针（首个元素的前一个）、尾指针（最后一个元素），存储数组本体

- **方法**：判空、判满、存、取、显示

单向队列使用一次就不能使用、没有达到复用的效果 --> 改造为环形队列

### 2. 数组模拟环形队列

- 变量：最大容量、头指针（直接指向第一个元素）、尾指针（直接指向最后一个元素）、存储数组本体
- **方法**：判空、判满、存、取、显示、计算队列元素个数
  - 判空：头 == 尾
  - 判满：（rear + 1）% maxSize == front
  - 存：rear =（rear + 1）% maxSize
  - 取：front = (front + 1) % maxSize
  - 计算个数：(rear + maxSize - front) % maxSize
  - 显示：从front遍历，至front + 个数，i % maxSize



## 三、链表-有序列表

### 1.单向链表

(data + next)，节点的方式存储，在内存中的存储不连续，分带头节点的和没有头节点的

head(不存放具体数据，表示单链表头) -->  [,] --> [,] --> [,] --> [,null]

需要temp临时指针，遍历temp = temp.next

Demo  -->  LinkedList - [Element(num、next、name、toString)]

- **增**：向尾部加，按序号加
  - temp = head
  - temp.next == null
  - temp.next = new
- **增**：按序号添加
  - temp = head
  - 遍历，temp.next.num > new.num，temp.next = null时退出
  - new.next = temp.next, temp.next = new
  - 特殊：temp.next.num = new.num , 报已有
- **删**：按序号删除
  - temp = head
  - 特殊：temp.next == null，报空
  - 遍历，temp.next.num == num
  - temp.next = temp.next.next
- **改**：按序号修改内容
  - temp = head.next
  - 特殊：temp == null，报空
  - 遍历，temp.num == item.num
  - temp.name = item.name, temp.grades = item.grades
- **查**：查看全部节点
  - temp = head.next
  - 特殊，temp == null，报空
  - 遍历，重写toString
- **查**：计算数组数量
- **查看倒数第k个节点**
  - 判空、计数、k值是否合理？
  - 遍历sum-k次
- **反转链表**
  - 新建一个链表头
  - 通过temp = head.next遍历链表
    - 先用nextNode存储temp.next，因为要编辑这个值
    - temp.next = reverseHead.next
    - reverseHead.next = temp
    - temp = nextNode
  - 通过head.next = reverseHead.next修改原链表

- **逆序打印链表**
  - **分析**：不采用上一个问题反转链表再打印，这样做改变了原来链表的结构还占用了内存，采用可以压入栈中的方式，通过**栈**的<u>先进后出</u>的特点实现逆序打印
  - 遍历链表，将每个节点入栈
  - 出栈，打印
- **按序号合并两顺序链表**
  - 新建一个链表头，新建三个指针分别指向新链表头（**cur**）、待合并链表1元素（**temp**），待合并链表2元素（**anotherTemp**）
  - 判断temp和anotherTemp的num大小决定**cur**应该指向谁
  - cur = cur.next，temp = temp.next / anotherTemp = anotherTemp.next（谁被使用谁更新）
  - 只要遍历完一个链表，就将cur.next指向另一个链表的当前元素，退出



### 2.双向链表

- **单向链表缺点**：①单向链表只能向一个方向查找，双向链表可以向前向后查找 ②单向链表不能独立删除节点，需要依靠辅助节点（temp指向待删除节点的前一个节点）

双向链表除了next还要有一个pre，

​	**增（尾）**：temp向后遍历（next）至null，temp.next = node，node.pre = temp

​	**增**：通过index添加，判断输入的合理性（index>0），两种思路

​		①遍历链表，找到index相等的节点，提示and return；找到temp.next.index > newNode.index，建立从右至左，两个双链接；退出循环时说明未找到，需要添加在尾部

​		②遍历链表（temp.next != null && temp.next.index < newNode.index），退出时temp指向链表尾部或指向需要添加newNode的位置（可能temp.next.index == newNode.index），三种情况需要分别判断

​	**删**：temp至被删除的节点，temp.pre.next = temp.next，temp.next.pre = temp.pre

​	**改**：同单向链表，遍历找到需要修改的节点，修改

​	**查**：temp向后(temp = temp.next)向前(temp = temp.pre)双向遍历



### 3. 循环链表-约瑟夫问题

![image-20240330194753102](.\image\image-20240330194753102.png)

使用**单向循环链表**解决 Boy -> CircleLinkedList -> Josephu，单向环形链表需要一个first

- **创建**环形单向链表
  - 输入 - 需要n个节点，判断合理性，n是否<=1
  - 循环（n次）
    - 若n==1,创建一个first节点 -> new Boy(i)，curBoy -> first
    - 若n!=1, curBoy.next -> new Boy(i), curBoy = curBoy.next
    - curBoy -> first

- **遍历**环形单向链表
  - 判空（first == null）
  - 打印first
  - 创建辅助指针curBoy = first.next，循环（curBoy != first）打印curBoy

- **约瑟夫问题**求解
  - 输入 - n：从第n号开始遍历；k：数到k的人出列
  - 创建辅助指针helper = first，做循环（helper.next != first），指向first的前一个元素
  - 移动到初始位置n：循环（n-1次）移动helper和first
  - 循环（first == helper）,链表中无元素
    - 循环（k - 1次）移动helper和first，此时first指向需要出列的人，helper指向其前一个人
    - 打印first，出圈：first = first.next, helper.next = first; 
  - 打印，剩的一个人



## 四、栈-先入后出

栈顶变化，栈底不变

栈的应用场景：子程序调用、处理递归调用、表达式的转换与求值、二叉树的遍历、图形深度优先搜索

### 1.栈的数组实现

ArrayStack: 栈顶top、最大容量maxSize、承载的数组stack[]

- **构造**：输入 - 最大容量，数组初始化，栈顶指向-1

- **判空**：top = -1

- **判满**：top = maxSize - 1

- **增（入栈）**：输入 - 数据n，判满，top++, stack[top] = n，

- **删（出栈）**：判空，output = stack[top], top--

- **查（从栈顶遍历）**：判空，循环（top != -1），打印stack[top]

### 2.栈的单向链表实现

**ListElement**(序号index, 值value, 指针next)，set、getValue

**LinkedListStack**(栈大小maxSize, 链表头指针head, 栈顶指针temp)

- **构造**：创建一个大小为maxSize的单向链表（head为头指针），栈顶指针temp指向head

- **判空**：temp == head

- **判满**：temp.next == null

- **增（入栈）**：输入 - 数据n，判满，temp = temp.next, temp.setValue(n)，

- **删（出栈）**：判空，存下temp.getValue, 创建新指针newTemp循环至temp前一个，temp = newTemp, 返回存下的值

- **查（从栈顶遍历）**：判空，创建helper指针，循环（i从temp.index逆序遍历至0）[循环至helper指向index为i的节点，打印节点，恢复helper指向头节点]

### 3.栈实现综合计算器

使用栈完成计算一个表达式的结果：numStack + operStack

- 通过index遍历表达式输入值（字符串）

  - index指向的是一个数字，直接入数栈numStack

  - index指向的是一个符号
    - 当前符号栈空，直接入栈
    - 若符号栈非空，判断符号的优先级
      - 优先级比栈中的操作符低或相同：需要从数字栈中pop出两个数、符号栈中pop出一个符号进行运算，得到结果入栈，将当前运算符入栈
      - 优先级比栈中操作高，直接入栈

- 顺序从数栈和符号栈中pop出相应内容进行计算

- 最后数栈仅剩一个数字

**使用 3+2*6-2 推演一遍**：

1. 3入栈
2. +入栈
3. 2入栈
4. *判断优先级更高，入栈
5. 6入栈
6. — 判断优先级更低，进行计算
   1. 从数栈pop出6和2，从符号栈pop出*
   2. 将计算结果6*2存入数栈
   3. 将 — 存入符号栈

7. 2入栈，遍历结束开始计算
8. 从数栈pop出2和12，从符号栈pop出 —，结果为10，存入数栈
9. 从数栈pop出10和3，从符号栈pop出+，结果为13，存入数栈
10. 因为符号栈为空，此时数栈仅剩一个数，计算结束返回结果

**代码**：isOper判别是否符号、isNum判别是否数字、priority优先级、cal计算两数结果

### 4.前缀中缀后缀表达式

**前缀表达式**：从右向左遍历，运算符位于操作数之前，遇到数字入栈，遇到符号取数运算

**中缀表达式**：正常的思维形式的表达式

**后缀表达式**：也叫逆波兰表达式，从左至右遍历，遇数字入栈，遇到符号取数运算

举例：(3+4)×5-6的前缀表达式为-×+3456，先弹出 - / 后弹出；后缀表达式为34+5×6-，后弹出 -/先弹出

### 5.栈实现逆波兰计算器

输入一个后缀表达式，用栈实现计算，支持小括号和多位数整数，仅支持整数

代码：isOper判符号、isNum判数字、cal计算两数结果

### 6.中缀表达式转后缀表达式

人容易理解的表达式 -> 计算机容易理解的表达式

例如：1+((2+3)*4)-5 => 1 2 3 + 4 * + 5 -

**思路分析**：

- 初始化两个栈（s1, s2）
- 从左至右扫描中缀表达式
  - 若为数字 -> s2
  - 若为运算符
    - 如果s1为空或者s1栈顶为 “(”  ，将此运算符直接入栈s1
    - 否则，如果该运算符优先级高于s1栈顶的运算符，将此运算符直接入栈s1
    - 否则，将s1栈顶的运算符弹出并压入s2中，再次判断该运算符与s1新栈顶的优先级
  - 若为括号
    - 如果是“(”，直接压入s1
    - 如果是“)”，依次弹出s1栈顶的运算符压入s2，直到遇到左括号为止，消除这对括号
- 扫描完成后将s1中剩余的符号压入s2
- s2出栈后的逆序为后缀表达式

## 五、递归

递归就是自己调用自己，每次调用时不相同，打印问题和阶乘问题

![image-20240416191400236](.\image\image-20240416191400236.png)

![image-20240416191219376](.\image\image-20240416191219376.png)

递归适合解决的问题：8皇后，汉诺塔，阶乘，迷宫，球和篮子

算法中使用：快排，归并排序，二分查找，分治算法

使用栈解决的问题 -> 使用递归代码更简洁

### 1.递归的重要原则

- 执行一个方法时就创建一个新的受保护的独立空间（栈空间）

- 方法的局部变量是独立的，不会相互影响

- 方法中使用引用类型变量，共享该引用型数据

- 递归必须向退出递归条件逼近，否则就是无限递归，出现StackOverFlowError

- 当一个方法执行完毕，或者遇到return就会返回，谁调用就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕

### 2.迷宫问题

![image-20240416192759858](.\image\image-20240416192759858.png)

![image-20240416203152077](.\image\image-20240416203152077.png)
